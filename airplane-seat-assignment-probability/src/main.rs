//! ## 飞机座位分配概率 ##
//! [原题目地址](https://leetcode-cn.com/problems/airplane-seat-assignment-probability/) 难度：<b>中等</b>
//! ### 题目描述 ###
//! 有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。
//! 
//! 剩下的乘客将会：
//! 
//! 如果他们自己的座位还空着，就坐到自己的座位上，
//! 
//! 当他们自己的座位被占用时，随机选择其他座位
//! 第 n 位乘客坐在自己的座位上的概率是多少？
//! 
//! 示例 1：
//! ```
//! 输入：n = 1
//! 输出：1.00000
//! 解释：第一个人只会坐在自己的位置上。
//! ```
//! 示例 2：
//! ```
//! 输入: n = 2
//! 输出: 0.50000
//! 解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。
//! ```
//! 提示：
//! 
//! * 1 <= n <= 10^5

pub struct Solution;

impl Solution {
    /// 这是动态规划版本，正确但会超时，n == 10000 时就超了。
    /// 思路是，1个人时，概率为1。
    /// 有n个人时，如果第1个人坐到了第i个位置，那么 [2..i) 的人都能做到自己位置上，此时第i个人的处境
    /// 相当于第一个人(此时第一个人的位置是他的正确位置), 面对n - i + 1个位置。
    /// 于是f(n) = sum(1/n * f[i]), 1<= i < n;
    pub fn nth_person_gets_nth_seat(n: i32) -> f64 {
        if n == 1 {
            return 1.0;
        }
        let mut dp = vec![1.0;n as usize + 1];
        for i in 2..=n as usize{
            dp[i] = 0.0;
            for j in 1..i {
                dp[i] += 1.0 / (i as f64) * dp[i - j];
            }
        }

        dp[n as usize]
    }

    /// 考虑对动态规划进行优化，发现dp[i] = 1/i * sum(dp[1]..dp[i-1]), i >= 2
    /// 于是sum(dp[1]..dp[i-1]) = i * dp[i],
    /// 于是 dp[i + 1] = 1/(i+1) * sum(dp[1]..dp[i]) = 1/(i+1) * sum(i * dp[i], dp[i]) = 1/(i+1) * (i+1)dp[i] = dp[i],
    /// 于是dp[1] = 1, dp[2] = 0.5, dp[3] .. dp[n] = dp[2] = 0.5，
    /// 完毕
    pub fn nth_person_gets_nth_seat_v2(n: i32) -> f64 {
        if n == 0 {
            1.0
        } else {
            0.5
        }
    }
}

fn main() {
    println!("Hello, world!");
}
